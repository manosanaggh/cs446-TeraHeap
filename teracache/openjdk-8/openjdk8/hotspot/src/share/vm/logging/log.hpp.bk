/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

// @author: Jack Kolokasis

#ifndef SHARE_LOGGING_LOG_HPP
#define SHARE_LOGGING_LOG_HPP

//
// Logging macros
//
// Usage:
//  log_<level>(<comma separated log tags>)(<printf-style log arguments>);
// e.g.
//  log_debug(logging)("message %d", i);
//
// Note that these macros will not evaluate the arguments unless the
// logging is enabled.
//
#define log_debug(...) (!log_is_enabled(Debug, __VA_ARGS__)) ?  (void)0 : LogImpl<LOG_TAGS(__VA_ARGS__)>::write<LogLevel::Debug>

// Convinient macro to test if the logging is enabled on te specified
// level for given tags.
#define log_is_enabled(level, ...) (LogImpl<LOG_TAGS(__VA_ARGS__)>::is_level(LogLevel::level))
class LogImpl {
    private:
        static const size_t LogBufferSize = 512;

    public:
        // Make sure no sure than the maximum number of tags have been
        // given,
        // The GuardTag allows this to be detected if/when it happens.
        // If the GuardTag is not __NO_TAG, the number of tags given
        // exceeds the maximum allowed.
        STATIC_ASSERT(GuardTag == LogTag::__NO_TAG); // Number of logging tags exceeds maximum supported!

        // Empty constructor to avoid warnings on MSVC about unused
        // variables
        // when the log instance is only used for static functions
        LogImpl() {
        }

        static bool is_level(LogLevelType level) {
            return LogTagSetMapping<T0, T1, T2, T3, T4>::target().is_level(level);
        }

        ATTRIBUTE_PRINTF(2, 3)
        static void write(LogLevelType level, const char* fmt, ...) {
            va_list args;
            va_start(args, fmt);
            vwrite(level, fmt, args);
            va_end(args);
        }

        static void write(const LogMessageBuffer& msg) {
            LogTagSetMapping<T0, T1, T2, T3, T4>::target().log(msg);
        };

        template <LogLevelType Level>
        ATTRIBUTE_PRINTF(1, 2)
        static void write(const char* fmt, ...) {
            va_list args;
            va_start(args, fmt);
            vwrite(Level, fmt, args);
            va_end(args);
        }

//
// Log class that embeds both log tags and a log level.
//
// The class provides a way to write the tags and log level once,
// so that redundant specification of tags or levels can be avoided.
//
// Example usage:
//  LogTarget(Debug, gc) out;
//  if (out.is_enabled()) {
//      ...
//      out.print("Worker: %u", i);
//      out.print(" data: %d", x);
//      ...
//      print_stats(out.stream());
//
#define LogTarget(level, ...) LogTargetImpl<LogLevel::level, LOG_TAGS(__VA_ARGS__)>

// Combines logging tags and a logging level.
template <LogLevelType level, 
         LogTagType T0, 
         LogTagType T1 = LogTag::__NO_TAG,
         LogTagType T2 = LogTag::__NO_TAG,
         LogTagType T3 = LogTag::__NO_TAG,
         LogTagType T4 = LogTag::__NO_TAG,
         LogTagType GuardTag = LogTag::__NO_TAG>

class LogTargetImpl {
    public:
        // Empty constructor to avoid warnings on MSVC about unusedd
        // variables when the log instance is only used for static
        // functions.
        LogTargetImple() {
        }

        static bool is_enabled() {
            return LogImpl<T0, T1, T2, T3, T4, GuardTag>::is_level(level);
        }

        static void print(const char* fmt, ...) ATRIBUTE_PRINTF(1, 2) {
            va_list args;
            va_start(args, fmt);
            LogImpl<T0, T1, T2, T3, T4, GuardTag>::write(level, fmt, args);
            va_end(args);
        }

};

#endif  // SHARE_LOGGING_LOG_HPP
